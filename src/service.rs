// Copyright 2015 MaidSafe.net limited.
//
// This SAFE Network Software is licensed to you under (1) the MaidSafe.net Commercial License,
// version 1.0 or later, or (2) The General Public License (GPL), version 3, depending on which
// licence you accepted on initial access to the Software (the "Licences").
//
// By contributing code to the SAFE Network Software, or to this project generally, you agree to be
// bound by the terms of the MaidSafe Contributor Agreement, version 1.0.  This, along with the
// Licenses can be found in the root directory of this project at LICENSE, COPYING and CONTRIBUTOR.
//
// Unless required by applicable law or agreed to in writing, the SAFE Network Software distributed
// under the GPL Licence is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.
//
// Please review the Licences for the specific language governing permissions and limitations
// relating to use of the SAFE Network Software.

use std::collections::{HashMap, HashSet};
use std::io;
use std::net;
use std::sync::{Arc, Mutex};
use service_discovery::ServiceDiscovery;
use sodiumoxide;
use sodiumoxide::crypto::box_;
use sodiumoxide::crypto::box_::{PublicKey, SecretKey};
use net2;
use nat_traversal::{MappedUdpSocket, MappingContext, PrivRendezvousInfo,
                    MappedTcpSocket, tcp_punch_hole,
                    PubRendezvousInfo, PunchedUdpSocket, gen_rendezvous_info,
                    SimpleUdpHolePunchServer, SimpleTcpHolePunchServer};


use sender_receiver::CrustMsg;
use connection::{RaiiTcpAcceptor, UtpRendezvousConnectMode};
use udp_listener::RaiiUdpListener;
use static_contact_info::StaticContactInfo;
use rand;
use config_handler::Config;
use connection::{Connection, ConnectionInfo};
use error::Error;
use connection;
use bootstrap;
use bootstrap::RaiiBootstrap;
use bootstrap_handler::BootstrapHandler;

use event::Event;
use socket_addr::SocketAddr;
use utp_connections;
use peer_id;
use peer_id::PeerId;

/// The result of a `Service::prepare_contact_info` call.
#[derive(Debug)]
pub struct ConnectionInfoResult {
    /// The token that was passed to `prepare_connection_info`.
    pub result_token: u32,
    /// The new contact info, if successful.
    pub result: io::Result<OurConnectionInfo>,
}

/// Contact info generated by a call to `Service::prepare_contact_info`.
#[derive(Debug)]
pub struct OurConnectionInfo {
    id: PeerId,
    udp_info: PubRendezvousInfo,
    tcp_info: PubRendezvousInfo,
    priv_udp_info: PrivRendezvousInfo,
    priv_tcp_info: PrivRendezvousInfo,
    // raii_tcp_acceptor: RaiiTcpAcceptor,
    // tcp_addrs: Vec<SocketAddr>,
    udp_socket: Option<net::UdpSocket>,
    tcp_socket: Option<net2::TcpBuilder>,
    static_contact_info: StaticContactInfo,
}

impl OurConnectionInfo {
    /// Convert our connection info to theirs so that we can give it to peer.
    pub fn to_their_connection_info(&self) -> TheirConnectionInfo {
        TheirConnectionInfo {
            udp_info: self.udp_info.clone(),
            tcp_info: self.tcp_info.clone(),
            static_contact_info: self.static_contact_info.clone(),
            // tcp_addrs: self.tcp_addrs.clone(),
            id: self.id,
        }
    }
}

/// Contact info used to connect to another peer.
#[derive(Debug, RustcEncodable, RustcDecodable)]
pub struct TheirConnectionInfo {
    udp_info: PubRendezvousInfo,
    tcp_info: PubRendezvousInfo,
    static_contact_info: StaticContactInfo,
    // tcp_addrs: Vec<SocketAddr>,
    id: PeerId,
}

impl TheirConnectionInfo {
    /// Returns the `PeerId` of the node that created this connection info.
    pub fn id(&self) -> PeerId {
        self.id
    }
}

/// A structure representing a connection manager.
///
/// This abstraction has a hidden dependency on a config file. Refer to [the docs for `FileHandler`]
/// (../file_handler/struct.FileHandler.html) and [an example config file flowchart]
/// (https://github.com/maidsafe/crust/blob/master/docs/vault_config_file_flowchart.pdf) for more
/// information.
pub struct Service {
    static_contact_info: Arc<Mutex<StaticContactInfo>>,
    peer_contact_infos: Arc<Mutex<Vec<StaticContactInfo>>>,
    bootstrap_cache: Arc<Mutex<BootstrapHandler>>,
    expected_peers: Arc<Mutex<HashSet<PeerId>>>,
    service_discovery: ServiceDiscovery<StaticContactInfo>,
    event_tx: ::CrustEventSender,
    bootstrap: RaiiBootstrap,
    our_keys: (PublicKey, SecretKey),
    connection_map: Arc<Mutex<HashMap<PeerId, Vec<Connection>>>>,
    mapping_context: Arc<MappingContext>,
    tcp_acceptor_port: Option<u16>,
    utp_acceptor_port: Option<u16>,
    raii_udp_listener: Option<RaiiUdpListener>,
    raii_tcp_acceptor: Option<RaiiTcpAcceptor>,
    tcp_enabled: bool,
    utp_enabled: bool,
    udp_hole_punch_server: SimpleUdpHolePunchServer<Arc<MappingContext>>,
    tcp_hole_punch_server: SimpleTcpHolePunchServer<Arc<MappingContext>>,
}

impl Service {
    /// Constructs a service. User needs to create an asynchronous channel, and provide
    /// the sender half to this method. Receiver will receive all `Event`s from this library.
    pub fn new(event_tx: ::CrustEventSender,
               service_discovery_port: u16)
               -> Result<Service, Error> {
        let config = try!(::config_handler::read_config_file());
        Service::new_with_config(event_tx, service_discovery_port, &config)
    }

    /// Constructs a service with the given config. User needs to create an asynchronous channel,
    /// and provide the sender half to this method. Receiver will receive all `Event`s from this
    /// library.
    pub fn new_with_config(event_tx: ::CrustEventSender,
                           service_discovery_port: u16,
                           config: &Config) -> Result<Service, Error> {
        sodiumoxide::init();

        let our_keys = box_::gen_keypair();

        // Form our initial contact info
        let static_contact_info = Arc::new(Mutex::new(StaticContactInfo {
            tcp_acceptors: Vec::new(),
            utp_custom_listeners: Vec::new(),
            udp_mapper_servers: Vec::new(),
            tcp_mapper_servers: Vec::new(),
        }));

        let cloned_contact_info = static_contact_info.clone();
        let generator = move || unwrap_result!(cloned_contact_info.lock()).clone();
        let service_discovery = try!(ServiceDiscovery::new_with_generator(service_discovery_port,
                                                                          generator));

        let mapping_context = try!(MappingContext::new().result_log()
                                   .or_else(|e| {
            Err(io::Error::new(io::ErrorKind::Other,
                               format!("Failed to create MappingContext: {}", e)))
        }));
        // Form initial peer contact infos - these will also contain echo-service addrs.
        let bootstrap_cache = Arc::new(Mutex::new(try!(BootstrapHandler::new())));
        let bootstrap_contacts = try!(bootstrap::get_known_contacts(&service_discovery,
                                                                    bootstrap_cache.clone(),
                                                                    &config));
        for peer_contact_info in bootstrap_contacts.iter() {
            mapping_context.add_simple_udp_servers(peer_contact_info.udp_mapper_servers.clone());
            mapping_context.add_simple_tcp_servers(peer_contact_info.tcp_mapper_servers.clone());
        }
        let peer_contact_infos = Arc::new(Mutex::new(bootstrap_contacts));

        let connection_map = Arc::new(Mutex::new(HashMap::new()));

        mapping_context.add_simple_udp_servers(config.udp_mapper_servers.clone());
        mapping_context.add_simple_tcp_servers(config.tcp_mapper_servers.clone());
        let mapping_context = Arc::new(mapping_context);

        let bootstrap = RaiiBootstrap::new(static_contact_info.clone(),
                                           peer_contact_infos.clone(),
                                           our_keys.0.clone(),
                                           event_tx.clone(),
                                           connection_map.clone(),
                                           bootstrap_cache.clone(),
                                           mapping_context.clone(),
                                           config.enable_tcp,
                                           config.enable_utp);

        let udp_hole_punch_server
            = try!(SimpleUdpHolePunchServer::new(mapping_context.clone()).result_log()
                   .or(Err(io::Error::new(io::ErrorKind::Other,
                                          "Failed to create UDP hole punch server"))));
        let tcp_hole_punch_server
            = try!(SimpleTcpHolePunchServer::new(mapping_context.clone()).result_log()
                   .or(Err(io::Error::new(io::ErrorKind::Other,
                                          "Failed to create TCP hole punch server"))));

        {
            let mut static_contact_info = static_contact_info.lock().unwrap();
            static_contact_info.udp_mapper_servers.extend(udp_hole_punch_server.addresses());
            static_contact_info.tcp_mapper_servers.extend(tcp_hole_punch_server.addresses());
        }

        let service = Service {
            static_contact_info: static_contact_info,
            peer_contact_infos: peer_contact_infos,
            bootstrap_cache: bootstrap_cache,
            service_discovery: service_discovery,
            expected_peers: Arc::new(Mutex::new(HashSet::new())),
            event_tx: event_tx,
            bootstrap: bootstrap,
            our_keys: our_keys,
            connection_map: connection_map,
            mapping_context: mapping_context.clone(),
            tcp_acceptor_port: config.tcp_acceptor_port,
            utp_acceptor_port: config.utp_acceptor_port,
            raii_udp_listener: None,
            raii_tcp_acceptor: None,
            tcp_enabled: config.enable_tcp,
            utp_enabled: config.enable_utp,
            udp_hole_punch_server: udp_hole_punch_server,
            tcp_hole_punch_server: tcp_hole_punch_server,
        };

        Ok(service)
    }

    /// Stop the bootstraping procedure
    pub fn stop_bootstrap(&mut self) {
        self.bootstrap.stop();
    }

    /// Starts accepting TCP connections.
    pub fn start_listening_tcp(&mut self) -> io::Result<()> {
        // Start the TCP Acceptor
        self.raii_tcp_acceptor = Some(try!(connection::start_tcp_accept(self.tcp_acceptor_port
                                                                            .unwrap_or(0),
                                                   self.static_contact_info.clone(),
                                                   self.our_keys.0.clone(),
                                                   self.peer_contact_infos.clone(),
                                                   self.event_tx.clone(),
                                                   self.connection_map.clone(),
                                                   self.bootstrap_cache.clone(),
                                                   self.expected_peers.clone(),
                                                   self.mapping_context.clone())));
        Ok(())
    }

    /// Starts accepting uTP connections.
    pub fn start_listening_utp(&mut self) -> io::Result<()> {
        // Start the UDP Listener
        // [TODO]: we should find the exteranl address and if we are directly acessabel here for all listerners. Also listen on ip4 and 6 for all protocols - 2016-02-10 11:28pm
        self.raii_udp_listener = Some(try!(RaiiUdpListener::new(self.utp_acceptor_port.unwrap_or(0),
                                           self.static_contact_info.clone(),
                                           self.our_keys.0.clone(),
                                           self.event_tx.clone(),
                                           self.connection_map.clone(),
                                           self.bootstrap_cache.clone(),
                                           self.mapping_context.clone())));
        Ok(())
    }

    /// Starts listening for beacon broadcasts.
    pub fn start_service_discovery(&mut self) {
        if !self.service_discovery.set_listen_for_peers(true) {
            error!("Failed to start listening for peers.");
        }
    }

    /// Get the hole punch servers addresses of nodes that we're connected to ordered by how likely
    /// they are to be on a seperate network.
    pub fn get_ordered_helping_nodes(&self) -> Vec<SocketAddr> {
        unimplemented!()
    }

    /// Send the given `data` to the peer with the given `PeerId`.
    pub fn send(&self, id: &PeerId, data: Vec<u8>) -> io::Result<()> {
        match unwrap_result!(self.connection_map.lock())
                  .get_mut(&id)
                  .and_then(|conns| conns.get_mut(0)) {
            None => {
                let msg = format!("No connection to peer {:?}", id);
                Err(io::Error::new(io::ErrorKind::Other, msg))
            }
            Some(connection) => connection.send(CrustMsg::Message(data)),
        }
    }

    /// Get information about our connection to a peer.
    pub fn connection_info(&self, id: &PeerId) -> Option<ConnectionInfo> {
        unwrap_result!(self.connection_map.lock())
                .get(&id)
                .and_then(|conns| conns.get(0))
                .and_then(|conn| Some(conn.get_info()))
    }

    /// Disconnect from the given peer and returns whether there was a connection at all.
    pub fn disconnect(&self, id: &PeerId) -> bool {
        unwrap_result!(self.connection_map.lock()).remove(&id).is_some()
    }

    /// Opens a connection to a remote peer. `public_endpoint` is the endpoint
    /// of the remote peer. `udp_socket` is a socket whose public address will
    /// be used by the other peer.
    ///
    /// A rendezvous connection setup is different to the traditional BSD socket
    /// setup in which there is no client or server side. Both ends create a
    /// socket and send somehow its public address to the other peer. Once both
    /// ends know each other address, both must call this function passing the
    /// socket which possess the address used by the other peer and passing the
    /// other peer's address.
    ///
    /// Only UDP-based protocols are supported. This means that you must use a
    /// uTP endpoint or nothing will happen.
    ///
    /// On success `Event::NewPeer` with connected `PeerId` will
    /// be sent to the event channel. On failure, nothing is reported. Failed
    /// attempts are not notified back up to the caller. If the caller wants to
    /// know of a failed attempt, it must maintain a record of the attempt
    /// itself which times out if a corresponding
    /// `Event::NewPeer` isn't received. See also [Process for
    /// Connecting]
    /// (https://github.com/maidsafe/crust/blob/master/docs/connect.md) for
    /// details on handling of connect in different protocols.
    pub fn connect(&self,
                   our_connection_info: OurConnectionInfo,
                   their_connection_info: TheirConnectionInfo) {

        let their_id = their_connection_info.id;
        if !unwrap_result!(self.connection_map.lock()).get(&their_id).into_iter().all(Vec::is_empty) {
            return;
        }

        {
            let i = &their_connection_info.static_contact_info;
            self.mapping_context.add_simple_udp_servers(i.udp_mapper_servers.iter().cloned());
            self.mapping_context.add_simple_tcp_servers(i.tcp_mapper_servers.iter().cloned());
        }

        let event_tx = self.event_tx.clone();
        let connection_map = self.connection_map.clone();
        let our_public_key = self.our_keys.0.clone();
        let our_contact_info = self.static_contact_info.clone();
        let bootstrap_cache = self.bootstrap_cache.clone();
        let tcp_enabled = self.tcp_enabled;
        let utp_enabled = self.utp_enabled;

        unwrap_result!(self.expected_peers.lock()).insert(their_connection_info.id);

        // TODO connect to all the socket addresses of peer in parallel
        let _joiner = thread!("PeerConnectionThread", move || {
            let mut last_err = io::Error::new(io::ErrorKind::NotFound,
                                              "No TCP acceptors found.");
            if tcp_enabled {
                let static_contact_info = their_connection_info.static_contact_info.clone();
                for tcp_addr in their_connection_info.static_contact_info.tcp_acceptors {
                    match connection::connect_tcp_endpoint(tcp_addr,
                                                           our_contact_info.clone(),
                                                           our_public_key,
                                                           event_tx.clone(),
                                                           connection_map.clone(),
                                                           Some(their_id)) {
                        Err(err) => {
                            last_err = err;
                            continue;
                        }
                        Ok(()) => {
                            unwrap_result!(bootstrap_cache.lock()).update_contacts(
                                vec![static_contact_info],
                                vec![]
                            );
                            return;
                        }
                    }
                };

            }

            if let Some(udp_socket) = our_connection_info.udp_socket {
                let res = PunchedUdpSocket::punch_hole(udp_socket,
                                                       our_connection_info.priv_udp_info,
                                                       their_connection_info.udp_info).result_log();
                let (udp_socket, public_endpoint) = match res {
                    Ok(PunchedUdpSocket { socket, peer_addr }) => (socket, peer_addr),
                    Err(_) => {
                        let mut cm = unwrap_result!(connection_map.lock());
                        if !cm.contains_key(&their_id) {
                            let ev = Event::NewPeer(Err(io::Error::new(io::ErrorKind::Other,
                                                                       "Failed to punch a hole")),
                                                    their_id);
                            let _ = event_tx.send(ev);
                        }
                        return;
                    }
                };

                match connection::utp_rendezvous_connect(udp_socket,
                                                         public_endpoint,
                                                         UtpRendezvousConnectMode::Normal(their_id),
                                                         our_public_key.clone(),
                                                         event_tx.clone(),
                                                         connection_map.clone()) {
                    Err(e) => {
                        let mut cm = unwrap_result!(connection_map.lock());
                        if !cm.contains_key(&their_id) {
                            let _ = event_tx.send(Event::NewPeer(Err(e), their_id));
                        }
                    }
                    Ok(connection) => return,
                };
            }

            if let Some(tcp_socket) = our_connection_info.tcp_socket {
                let res = tcp_punch_hole(tcp_socket,
                                         our_connection_info.priv_tcp_info,
                                         their_connection_info.tcp_info).result_log();
                match res {
                    Ok(tcp_stream) => {
                        match connection::tcp_rendezvous_connect(connection_map.clone(),
                                                                 event_tx.clone(),
                                                                 tcp_stream,
                                                                 their_connection_info.id) {
                            Ok(()) => {
                                let mut c_map = unwrap_result!(connection_map.lock());
                                let connections = c_map.entry(their_id).or_insert_with(|| Vec::with_capacity(1));
                                if connections.is_empty() {
                                    let _ = event_tx.send(Event::NewPeer(Ok(()), their_id));
                                }
                                return;
                            },
                            Err(e) => {
                                last_err = From::from(e);
                            },
                        };
                    },
                    Err(e) => {
                        last_err = From::from(e);
                    },
                };
            }

            if unwrap_result!(connection_map.lock()).get(&their_id).into_iter().all(Vec::is_empty) {
                let _ = event_tx.send(Event::NewPeer(Err(last_err), their_id));
            }
        });
    }

    /// Lookup a mapped udp socket based on result_token
    pub fn prepare_connection_info(&mut self, result_token: u32) {
        // FIXME: If the listeners are directly addressable (direct full cone or upnp mapped etc.
        // then our conact info is our static liseners
        // for udp we can map another socket, but use same local port if accessable/mapped
        // otherwise do following
        let our_static_contact_info = self.static_contact_info.clone();
        let event_tx = self.event_tx.clone();

        let result_external_socket = MappedUdpSocket::new(&self.mapping_context)
            .result_log();
        let mapping_context = self.mapping_context.clone();
        let our_pub_key = self.our_keys.0.clone();
        let tcp_enabled = self.tcp_enabled;
        let utp_enabled = self.utp_enabled;
        let _joiner = thread!("PrepareContactInfo", move || {
            let (udp_socket, (our_priv_udp_info, our_pub_udp_info)) = if utp_enabled {
                match MappedUdpSocket::new(&mapping_context).result_log() {
                    Ok(MappedUdpSocket { socket, endpoints }) => {
                        (Some(socket), gen_rendezvous_info(endpoints))
                    }
                    Err(e) => {
                        let _ = event_tx.send(Event::ConnectionInfoPrepared(ConnectionInfoResult {
                            result_token: result_token,
                            result: Err(io::Error::new(io::ErrorKind::Other,
                                                       "Cannot map UDP socket")),
                        }));
                        return;
                    }
                }
            }
            else {
                (None, gen_rendezvous_info(vec![]))
            };

            let (tcp_socket, (our_priv_tcp_info, our_pub_tcp_info)) = if tcp_enabled {
                match MappedTcpSocket::new(&mapping_context).result_log() {
                    Ok(MappedTcpSocket { socket, endpoints }) => {
                        (Some(socket), gen_rendezvous_info(endpoints))
                    }
                    Err(e) => {
                        let _ = event_tx.send(Event::ConnectionInfoPrepared(ConnectionInfoResult {
                            result_token: result_token,
                            result: Err(io::Error::new(io::ErrorKind::Other,
                                                       "Cannot map TCP socket")),
                        }));
                        return;
                    }
                }
            }
            else {
                (None, gen_rendezvous_info(vec![]))
            };

            let send = Event::ConnectionInfoPrepared(ConnectionInfoResult {
                result_token: result_token,
                result: Ok(OurConnectionInfo {
                    id: peer_id::new_id(our_pub_key),
                    udp_info: our_pub_udp_info,
                    tcp_info: our_pub_tcp_info,
                    priv_udp_info: our_priv_udp_info,
                    priv_tcp_info: our_priv_tcp_info,
                    // raii_tcp_acceptor: unimplemented!(),
                    // tcp_addrs: unimplemented!(),
                    // why are we starting a tcp acceptor?
                    // Are tcp acceptors being used to do rendezvous connections now?
                    // coz that doesn't make sense
                    udp_socket: udp_socket,
                    tcp_socket: tcp_socket,
                    static_contact_info: unwrap_result!(our_static_contact_info.lock()).clone(),
                }),
            });
            let _ = event_tx.send(send);
        });
    }

    /// Returns our ID.
    pub fn id(&self) -> PeerId {
        peer_id::new_id(self.our_keys.0)
    }
}

impl Drop for Service {
    fn drop(&mut self) {
        // Disconnect from all peers when we drop the service
        let mut cm = unwrap_result!(self.connection_map.lock());
        cm.clear();
    }
}

#[cfg(test)]
mod test {
    use super::*;
    use event::Event;
    use endpoint::Protocol;

    use std::mem;
    use std::time::Duration;
    use std::sync::{Mutex, Arc, Barrier};
    use std::sync::mpsc;
    use std::sync::mpsc::Receiver;
    use std::thread;
    use std::thread::JoinHandle;
    use std::collections::{hash_map, HashMap};

    use crossbeam;
    use void::Void;
    use maidsafe_utilities::event_sender::{MaidSafeObserver, MaidSafeEventCategory};

    fn get_event_sender()
        -> (::CrustEventSender,
            Receiver<MaidSafeEventCategory>,
            Receiver<Event>)
    {
        let (category_tx, category_rx) = mpsc::channel();
        let event_category = MaidSafeEventCategory::Crust;
        let (event_tx, event_rx) = mpsc::channel();

        (MaidSafeObserver::new(event_tx, event_category, category_tx),
         category_rx,
         event_rx)
    }

    fn timebomb<R, F>(dur: Duration, f: F) -> R
            where R: Send,
                  F: Send + FnOnce() -> R
    {
        crossbeam::scope(|scope| {
            let thread_handle = thread::current();
            let (done_tx, done_rx) = mpsc::channel::<Void>();
            let jh = scope.spawn(move || {
                let ret = f();
                drop(done_tx);
                thread_handle.unpark();
                ret
            });
            thread::park_timeout(dur);
            match done_rx.try_recv() {
                Ok(x) => match x {},
                Err(mpsc::TryRecvError::Empty) => panic!("Timed out!"),
                Err(mpsc::TryRecvError::Disconnected) => jh.join(),
            }
        })
    }

    #[test]
    fn start_stop_service() {
        let (event_sender, _, _) = get_event_sender();
        let _service = unwrap_result!(Service::new(event_sender, 44444));
    }

    fn two_services_bootstrap_communicate_and_exit(port: u16, use_tcp: bool, use_udp: bool) {
        assert!(use_tcp || use_udp);

        let (event_sender_0, category_rx_0, event_rx_0) = get_event_sender();
        let (event_sender_1, category_rx_1, event_rx_1) = get_event_sender();

        let mut service_0 = unwrap_result!(Service::new(event_sender_0, port));
        if use_tcp {
            unwrap_result!(service_0.start_listening_tcp());
        }
        if use_udp {
            unwrap_result!(service_0.start_listening_utp());
        }
        // let service_0 finish bootstrap - since it is the zero state, it should not find any peer
        // to bootstrap
        {
            let event_rxd = unwrap_result!(event_rx_0.recv());
            match event_rxd {
                Event::BootstrapFinished => (),
                _ => panic!("Received unexpected event: {:?}", event_rxd),
            }
        }
        service_0.start_service_discovery();

        let mut service_1 = unwrap_result!(Service::new(event_sender_1, port));
        if use_tcp {
            unwrap_result!(service_1.start_listening_tcp());
        }
        if use_udp {
            unwrap_result!(service_1.start_listening_utp());
        }

        // let service_1 finish bootstrap - it should bootstrap off service_0
        let id_0 = {
            let event_rxd = unwrap_result!(event_rx_1.recv());
            match event_rxd {
                Event::BootstrapConnect(their_id) => their_id,
                _ => panic!("Received unexpected event: {:?}", event_rxd),
            }
        };

        // now service_1 should get BootstrapFinished
        {
            let event_rxd = unwrap_result!(event_rx_1.recv());
            match event_rxd {
                Event::BootstrapFinished => (),
                _ => panic!("Received unexpected event: {:?}", event_rxd),
            }
        }

        // service_0 should have received service_1's bootstrap connection by now
        let id_1 = match unwrap_result!(event_rx_0.recv()) {
            Event::BootstrapAccept(their_id) => their_id,
            _ => panic!("0 Should have got a new connection from 1."),
        };

        // TODO: Evaluate whether these are still needed.
        // if use_tcp {
        // assert_eq!(*connection_0_to_1.get_protocol(), Protocol::Tcp);
        // assert_eq!(*connection_1_to_0.get_protocol(), Protocol::Tcp);
        // } else {
        // assert_eq!(*connection_0_to_1.get_protocol(), Protocol::Utp);
        // assert_eq!(*connection_1_to_0.get_protocol(), Protocol::Utp);
        // }


        assert!(id_0 != id_1);

        // send data from 0 to 1
        {
            let data_txd = vec![0, 1, 255, 254, 222, 1];
            unwrap_result!(service_0.send(&id_1, data_txd.clone()));

            // 1 should rx data
            let (data_rxd, peer_id) = {
                let event_rxd = unwrap_result!(event_rx_1.recv());
                match event_rxd {
                    Event::NewMessage(their_id, msg) => (msg, their_id),
                    _ => panic!("Received unexpected event: {:?}", event_rxd),
                }
            };

            assert_eq!(data_rxd, data_txd);
            assert_eq!(peer_id, id_0);
        }

        // send data from 1 to 0
        {
            let data_txd = vec![10, 11, 155, 214, 202];
            unwrap_result!(service_1.send(&id_0, data_txd.clone()));

            // 0 should rx data
            let (data_rxd, peer_id) = {
                let event_rxd = unwrap_result!(event_rx_0.recv());
                match event_rxd {
                    Event::NewMessage(their_id, msg) => (msg, their_id),
                    _ => panic!("Received unexpected event: {:?}", event_rxd),
                }
            };

            assert_eq!(data_rxd, data_txd);
            assert_eq!(peer_id, id_1);
        }

        assert!(service_0.disconnect(&id_1));

        match unwrap_result!(event_rx_1.recv()) {
            Event::LostPeer(id) => assert_eq!(id, id_0),
            e => panic!("Received unexpected event: {:?}", e),
        }

        // Drop services and make sure the event channels close
        drop(service_0);
        let (done_tx, done_rx) = mpsc::channel();
        let tj = thread!("Drain event channel messages", move || {
            match event_rx_0.recv() {
                Ok(e) => panic!("Received unexpected event when shutting down: {:?}", e),
                Err(mpsc::RecvError) => (),
            };
            done_tx.send(());
        });
        thread::park_timeout(Duration::from_secs(5));
        unwrap_result!(done_rx.try_recv());
        unwrap_result!(tj.join());

        drop(service_1);
        let (done_tx, done_rx) = mpsc::channel();
        let tj = thread!("Drain event channel messages", move || {
            match event_rx_1.recv() {
                Ok(e) => panic!("Received unexpected event when shutting down: {:?}", e),
                Err(mpsc::RecvError) => (),
            };
            done_tx.send(());
        });
        thread::park_timeout(Duration::from_secs(5));
        unwrap_result!(done_rx.try_recv());
        unwrap_result!(tj.join());
    }

    #[test]
    fn start_two_services_bootstrap_communicate_exit_tcp() {
        two_services_bootstrap_communicate_and_exit(45666, true, false);
    }

    #[test]
    fn start_two_services_bootstrap_communicate_exit_udp() {
        two_services_bootstrap_communicate_and_exit(45667, false, true);
    }

    #[test]
    fn start_two_services_bootstrap_communicate_exit_tcp_and_udp() {
        two_services_bootstrap_communicate_and_exit(45668, true, true);
    }

    #[test]
    fn drop_disconnects() {
        let port = 45669;
        let (event_sender_0, category_rx_0, event_rx_0) = get_event_sender();
        let (event_sender_1, category_rx_1, event_rx_1) = get_event_sender();

        let mut service_0 = unwrap_result!(Service::new(event_sender_0, port));
        unwrap_result!(service_0.start_listening_tcp());

        // Let service_0 finish bootstrap - it should not find any peer.
        match unwrap_result!(event_rx_0.recv()) {
            Event::BootstrapFinished => (),
            event_rxd => panic!("Received unexpected event: {:?}", event_rxd),
        }
        service_0.start_service_discovery();

        let mut service_1 = unwrap_result!(Service::new(event_sender_1, port));
        unwrap_result!(service_1.start_listening_tcp());

        // Let service_1 finish bootstrap - it should bootstrap off service_0.
        let id_0 = match unwrap_result!(event_rx_1.recv()) {
            Event::BootstrapConnect(their_id) => their_id,
            event => panic!("Received unexpected event: {:?}", event),
        };

        // Now service_1 should get BootstrapFinished.
        match unwrap_result!(event_rx_1.recv()) {
            Event::BootstrapFinished => (),
            event => panic!("Received unexpected event: {:?}", event),
        }

        // service_0 should have received service_1's bootstrap connection by now.
        let id_1 = match unwrap_result!(event_rx_0.recv()) {
            Event::BootstrapAccept(their_id) => their_id,
            _ => panic!("0 Should have got a new connection from 1."),
        };

        // Dropping service_0 should make service_1 receive a LostPeer event.
        drop(service_0);
        match unwrap_result!(event_rx_1.recv()) {
            Event::LostPeer(id) => assert_eq!(id, id_0),
            event => panic!("Received unexpected event: {:?}", event),
        }
    }

    fn start_two_service_rendezvous_connect(protocol: Protocol) {
        let (event_sender_0, category_rx_0, event_rx_0) = get_event_sender();
        let (event_sender_1, category_rx_1, event_rx_1) = get_event_sender();

        let mut config = unwrap_result!(::config_handler::read_config_file());
        match protocol {
            Protocol::Tcp => config.enable_utp = false,
            Protocol::Utp => config.enable_tcp = false,
        };

        let mut service_0 = unwrap_result!(Service::new_with_config(event_sender_0, 1234, &config));
        // let service_0 finish bootstrap - since it is the zero state, it should not find any peer
        // to bootstrap
        {
            let event_rxd = unwrap_result!(event_rx_0.recv());
            match event_rxd {
                Event::BootstrapFinished => (),
                _ => panic!("Received unexpected event: {:?}", event_rxd),
            }
        }

        let mut service_1 = unwrap_result!(Service::new_with_config(event_sender_1, 1234, &config));
        // let service_0 finish bootstrap - since it is the zero state, it should not find any peer
        // to bootstrap
        {
            let event_rxd = unwrap_result!(event_rx_1.recv());
            match event_rxd {
                Event::BootstrapFinished => (),
                _ => panic!("Received unexpected event: {:?}", event_rxd),
            }
        }

        const PREPARE_CI_TOKEN: u32 = 1234;

        service_0.prepare_connection_info(PREPARE_CI_TOKEN);
        let our_ci_0 = {
            let event_rxd = unwrap_result!(event_rx_0.recv());
            match event_rxd {
                Event::ConnectionInfoPrepared(cir) => {
                    assert_eq!(cir.result_token, PREPARE_CI_TOKEN);
                    unwrap_result!(cir.result)
                }
                _ => panic!("Received unexpected event: {:?}", event_rxd),
            }
        };

        service_1.prepare_connection_info(PREPARE_CI_TOKEN);
        let our_ci_1 = {
            let event_rxd = unwrap_result!(event_rx_1.recv());
            match event_rxd {
                Event::ConnectionInfoPrepared(cir) => {
                    assert_eq!(cir.result_token, PREPARE_CI_TOKEN);
                    unwrap_result!(cir.result)
                }
                _ => panic!("Received unexpected event: {:?}", event_rxd),
            }
        };

        let their_ci_0 = our_ci_0.to_their_connection_info();
        let their_ci_1 = our_ci_1.to_their_connection_info();

        service_0.connect(our_ci_0, their_ci_1);
        service_1.connect(our_ci_1, their_ci_0);

        let id_1 = match unwrap_result!(event_rx_0.recv()) {
            Event::NewPeer(Ok(()), their_id) => their_id,
            m => panic!("0 Should have connected to 1. Got message {:?}", m),
        };

        let id_0 = match unwrap_result!(event_rx_1.recv()) {
            Event::NewPeer(Ok(()), their_id) => their_id,
            m => panic!("1 Should have connected to 0. Got message {:?}", m),
        };

        // send data from 0 to 1
        {
            let data_txd = vec![0, 1, 255, 254, 222, 1];
            unwrap_result!(service_0.send(&id_1, data_txd.clone()));

            // 1 should rx data
            let (data_rxd, peer_id) = {
                let event_rxd = unwrap_result!(event_rx_1.recv());
                match event_rxd {
                    Event::NewMessage(their_id, msg) => (msg, their_id),
                    _ => panic!("Received unexpected event: {:?}", event_rxd),
                }
            };

            assert_eq!(data_rxd, data_txd);
            assert_eq!(peer_id, id_0);
        }

        // send data from 1 to 0
        {
            let data_txd = vec![10, 11, 155, 214, 202];
            unwrap_result!(service_1.send(&id_0, data_txd.clone()));

            // 0 should rx data
            let (data_rxd, peer_id) = {
                let event_rxd = unwrap_result!(event_rx_0.recv());
                match event_rxd {
                    Event::NewMessage(their_id, msg) => (msg, their_id),
                    _ => panic!("Received unexpected event: {:?}", event_rxd),
                }
            };

            assert_eq!(data_rxd, data_txd);
            assert_eq!(peer_id, id_1);
        }

        // Drop services and make sure the event channels close
        drop(service_0);
        let (done_tx, done_rx) = mpsc::channel();
        let tj = thread!("Drain event channel messages", move || {
            for _ in event_rx_0 {}
            done_tx.send(());
        });
        thread::park_timeout(Duration::from_secs(5));
        unwrap_result!(done_rx.try_recv());
        unwrap_result!(tj.join());

        drop(service_1);
        let (done_tx, done_rx) = mpsc::channel();
        let tj = thread!("Drain event channel messages", move || {
            for _ in event_rx_1 {}
            done_tx.send(());
        });
        thread::park_timeout(Duration::from_secs(5));
        unwrap_result!(done_rx.try_recv());
        unwrap_result!(tj.join());
    }

    #[test]
    fn start_two_service_utp_rendezvous_connect() {
        start_two_service_rendezvous_connect(Protocol::Utp);
    }

    #[test]
    fn start_two_service_tcp_rendezvous_connect() {
        start_two_service_rendezvous_connect(Protocol::Tcp);
    }

    fn start_three_service_rendezvous_connect(protocol: Protocol) {
        const NUM_SERVICES: usize = 3;
        const MSG_SIZE: usize = 1024;
        const NUM_MSGS: usize = 256;

        struct TestNode {
            event_rx: Receiver<Event>,
            category_rx: Receiver<MaidSafeEventCategory>,
            service: Service,
            connection_id_rx: Receiver<TheirConnectionInfo>,
            our_cis: Vec<OurConnectionInfo>,
            our_index: usize,
        }

        impl TestNode {
            fn new(index: usize, protocol: Protocol) -> (TestNode, mpsc::Sender<TheirConnectionInfo>) {
                let (event_sender, category_rx, event_rx) = get_event_sender();
                let mut config = unwrap_result!(::config_handler::read_config_file());
                match protocol {
                    Protocol::Tcp => config.enable_utp = false,
                    Protocol::Utp => config.enable_tcp = false,
                };
                let service = unwrap_result!(Service::new_with_config(event_sender, 0, &config));
                match unwrap_result!(event_rx.recv()) {
                    Event::BootstrapFinished => (),
                    m => panic!("Expected BootstrapFinished, got:{:?}", m),
                };
                let (ci_tx, ci_rx) = mpsc::channel();
                (TestNode {
                    event_rx: event_rx,
                    category_rx: category_rx,
                    service: service,
                    connection_id_rx: ci_rx,
                    our_cis: Vec::new(),
                    our_index: index,
                }, ci_tx)
            }

            fn make_connection_infos(&mut self, ci_txs: &[mpsc::Sender<TheirConnectionInfo>]) {
                for (i, ci_tx) in ci_txs.iter().enumerate() {
                    if i == self.our_index {
                        continue;
                    }
                    const PREPARE_CI_TOKEN: u32 = 1234;
                    self.service.prepare_connection_info(PREPARE_CI_TOKEN);
                    let our_ci = match unwrap_result!(self.event_rx.recv()) {
                        Event::ConnectionInfoPrepared(cir) => {
                            assert_eq!(cir.result_token, PREPARE_CI_TOKEN);
                            unwrap_result!(cir.result)
                        }
                        m => panic!("Received unexpected event: m == {:?}", m),
                    };
                    let their_ci = our_ci.to_their_connection_info();
                    ci_tx.send(their_ci);
                    self.our_cis.push(our_ci);
                }
            }

            fn run(self, send_barrier: Arc<Barrier>, drop_barrier: Arc<Barrier>) -> JoinHandle<()> {
                thread!("run!", move || {
                    for (our_ci, their_ci) in self.our_cis.into_iter().zip(self.connection_id_rx.into_iter()) {
                        self.service.connect(our_ci, their_ci);
                    }
                    let mut their_ids = HashMap::new();
                    for _ in 0..(NUM_SERVICES - 1) {
                        let their_id = match unwrap_result!(self.event_rx.recv()) {
                            Event::NewPeer(Ok(()), their_id) => their_id,
                            m => panic!("Expected NewPeer message. Got message {:?}", m),
                        };
                        match their_ids.insert(their_id, 0u32) {
                            Some(_) => panic!("Received two NewPeer events for same peer!"),
                            None => (),
                        };
                    }

                    // Wait until all nodes have connected to each other before we start
                    // exchanging messages.
                    let _ = send_barrier.wait();

                    for their_id in their_ids.keys() {
                        for n in 0..NUM_MSGS {
                            let mut msg = Vec::with_capacity(MSG_SIZE);
                            for _ in 0..MSG_SIZE {
                                msg.push(n as u8);
                            }
                            self.service.send(their_id, msg);
                        };
                    }

                    for _ in 0..((NUM_SERVICES - 1) * NUM_MSGS) {
                        match unwrap_result!(self.event_rx.recv()) {
                            Event::NewMessage(their_id, msg) => {
                                let n = msg[0];
                                assert_eq!(msg.len(), MSG_SIZE);
                                for m in msg {
                                    assert_eq!(n, m);
                                };
                                match their_ids.entry(their_id.clone()) {
                                    hash_map::Entry::Occupied(mut oe) => {
                                        let next_msg = oe.get_mut();
                                        assert_eq!(*next_msg, n as u32);
                                        *next_msg += 1;
                                    },
                                    hash_map::Entry::Vacant(ve) => panic!("impossible!"),
                                }
                            },
                            m => panic!("Unexpected msg receiving NewMessage: {:?}", m),
                        }
                    }

                    // Wait until all nodes have finished exchanging messages before we start
                    // disconnecting.
                    let _ = drop_barrier.wait();

                    drop(self.service);
                    match self.event_rx.recv() {
                        Ok(m) => match m {
                            Event::LostPeer(..) => (),
                            _ => panic!("Unexpected message when shutting down: {:?}", m),
                        },
                        Err(mpsc::RecvError) => (),
                    }
                })
            }
        }

        let mut test_nodes = Vec::new();
        let mut ci_txs = Vec::new();
        for i in 0..NUM_SERVICES {
            let (test_node, ci_tx) = TestNode::new(i, protocol);
            test_nodes.push(test_node);
            ci_txs.push(ci_tx);
        }

        for test_node in &mut test_nodes {
            test_node.make_connection_infos(&ci_txs);
        }

        let send_barrier = Arc::new(Barrier::new(NUM_SERVICES));
        let drop_barrier = Arc::new(Barrier::new(NUM_SERVICES));
        let mut threads = Vec::new();
        for test_node in test_nodes {
            let send_barrier = send_barrier.clone();
            let drop_barrier = drop_barrier.clone();
            threads.push(test_node.run(send_barrier, drop_barrier));
        }

        // Wait one hundred millisecond per message
        // TODO(canndrew): drop this limit
        let timeout_ms = 100 * (NUM_MSGS * (NUM_SERVICES * (NUM_SERVICES - 1)) / 2) as u64;
        timebomb(Duration::from_millis(timeout_ms), move || {
            for thread in threads {
                unwrap_result!(thread.join());
            }
        });
    }

    fn start_three_service_utp_rendezvous_connect() {
        start_three_service_rendezvous_connect(Protocol::Utp);
    }

    fn start_three_service_tcp_rendezvous_connect() {
        start_three_service_rendezvous_connect(Protocol::Tcp);
    }
}
