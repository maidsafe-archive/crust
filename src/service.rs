// Copyright 2016 MaidSafe.net limited.
//
// This SAFE Network Software is licensed to you under (1) the MaidSafe.net Commercial License,
// version 1.0 or later, or (2) The General Public License (GPL), version 3, depending on which
// licence you accepted on initial access to the Software (the "Licences").
//
// By contributing code to the SAFE Network Software, or to this project generally, you agree to be
// bound by the terms of the MaidSafe Contributor Agreement, version 1.0.  This, along with the
// Licenses can be found in the root directory of this project at LICENSE, COPYING and CONTRIBUTOR.
//
// Unless required by applicable law or agreed to in writing, the SAFE Network Software distributed
// under the GPL Licence is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.
//
// Please review the Licences for the specific language governing permissions and limitations
// relating to use of the SAFE Network Software.

use maidsafe_utilities::thread::RaiiThreadJoiner;
use mio::{self, EventLoop, NotifyError};
use net2;
use sodiumoxide::crypto::box_::{self, PublicKey, SecretKey};
use std::collections::HashMap;
use std::io;
use std::sync::{Arc, Mutex};
use std::sync::mpsc;

use bootstrap_states::GetBootstrapContacts;
use config_handler::{self, Config};
use connection_states::{EstablishConnection, ForwardConnectionEvents};
use core::{Core, CoreMessage, State, StateHandle};
use core::channel::{self, Sender};
use event::Event;
use error::Error;
use listen_states::Listen;
use nat_traversal::{MappedTcpSocket, MappingContext, PrivRendezvousInfo, PubRendezvousInfo,
                    gen_rendezvous_info};
use peer_id::{self, PeerId};
use static_contact_info::StaticContactInfo;

/// The result of a `Service::prepare_contact_info` call.
#[derive(Debug)]
pub struct ConnectionInfoResult {
    /// The token that was passed to `prepare_connection_info`.
    pub result_token: u32,
    /// The new contact info, if successful.
    pub result: io::Result<OurConnectionInfo>,
}

/// Contact info generated by a call to `Service::prepare_contact_info`.
#[derive(Debug)]
pub struct OurConnectionInfo {
    id: PeerId,
    tcp_info: PubRendezvousInfo,
    priv_tcp_info: PrivRendezvousInfo,
    tcp_socket: Option<net2::TcpBuilder>,
    static_contact_info: StaticContactInfo,
}

impl OurConnectionInfo {
    /// Convert our connection info to theirs so that we can give it to peer.
    pub fn to_their_connection_info(&self) -> TheirConnectionInfo {
        TheirConnectionInfo {
            tcp_info: self.tcp_info.clone(),
            static_contact_info: self.static_contact_info.clone(),
            // tcp_addrs: self.tcp_addrs.clone(),
            id: self.id,
        }
    }
}


/// Contact info used to connect to another peer.
#[derive(Debug, RustcEncodable, RustcDecodable)]
pub struct TheirConnectionInfo {
    tcp_info: PubRendezvousInfo,
    static_contact_info: StaticContactInfo,
    id: PeerId,
}

impl TheirConnectionInfo {
    /// Returns the `PeerId` of the node that created this connection info.
    pub fn id(&self) -> PeerId {
        self.id
    }
}

pub type SharedConnectionMap = Arc<Mutex<HashMap<PeerId, StateHandle>>>;

fn new_shared_connection_map() -> SharedConnectionMap {
    Arc::new(Mutex::new(HashMap::new()))
}

/// A structure representing a connection manager.
pub struct Service {
    // This is the connection map -> PeerId -> StateHandle
    bootstrap_handle: StateHandle,
    connection_map: SharedConnectionMap,
    connect_tx: Sender<(StateHandle, Option<PeerId>)>,
    event_tx: ::CrustEventSender,
    is_listening: bool,
    mapping_context: Arc<MappingContext>,
    mio_tx: mio::Sender<CoreMessage>,
    our_keys: (PublicKey, SecretKey),
    static_contact_info: Arc<Mutex<StaticContactInfo>>,
    _thread_joiner: RaiiThreadJoiner,
}

impl Service {
    /// Constructs a service.
    pub fn new(event_tx: ::CrustEventSender) -> Result<Self, Error> {
        Service::with_config(event_tx, &try!(config_handler::read_config_file()))
    }

    /// Constructs a service with the given config. User needs to create an asynchronous channel,
    /// and provide the sender half to this method. Receiver will receive all `Event`s from this
    /// library.
    pub fn with_config(event_tx: ::CrustEventSender, config: &Config) -> Result<Service, Error> {
        let event_loop = try!(EventLoop::new());
        let mio_tx = event_loop.channel();
        let our_keys = box_::gen_keypair();

        // Form our initial contact info
        let static_contact_info = Arc::new(Mutex::new(StaticContactInfo {
            tcp_acceptors: Vec::new(),
            tcp_mapper_servers: Vec::new(),
        }));

        let mapping_context = try!(MappingContext::new()
                                       .result_log()
                                       .or_else(|e| {
                                           Err(io::Error::new(io::ErrorKind::Other,
                                                              format!("Failed to create \
                                                                       MappingContext: {}",
                                                                      e)))
                                       }));


        let joiner = RaiiThreadJoiner::new(thread!("Crust event loop", move || {
            Core::run(event_loop).expect("Core failed to run");
        }));

        let connection_map = new_shared_connection_map();

        let bootstrap_handle = try!(start_bootstrap(&mio_tx,
                                                    config.clone(),
                                                    connection_map.clone(),
                                                    event_tx.clone()));

        let connect_tx = try!(start_forward_connection_events(&mio_tx,
                                                              connection_map.clone(),
                                                              event_tx.clone()));

        Ok(Service {
            bootstrap_handle: bootstrap_handle,
            connection_map: connection_map,
            connect_tx: connect_tx,
            event_tx: event_tx,
            is_listening: false,
            mapping_context: Arc::new(mapping_context),
            mio_tx: mio_tx,
            our_keys: our_keys,
            // sender: sender,
            static_contact_info: static_contact_info,
            _thread_joiner: joiner,
        })
    }

    /// Stop the bootstraping procedure
    pub fn stop_bootstrap(&mut self) -> Result<(), Error> {
        let handle = self.bootstrap_handle;

        try!(self.post(move |mut core, mut event_loop| {
            let state = core.get_state(&handle).expect("Bootstrap state not found");
            state.borrow_mut().terminate(&mut core, &mut event_loop);
        }));

        Ok(())
    }

    /// Starts accepting TCP connections.
    pub fn start_listening_tcp(&mut self) -> Result<(), Error> {
        // Prevent creating more than one listener.
        if self.is_listening {
            return Ok(());
        } else {
            self.is_listening = true;
        }

        let connection_map = self.connection_map.clone();

        try!(self.post(move |core, event_loop| {
            let _ = Listen::start(core, event_loop, connection_map);
        }));

        Ok(())
    }

    /// connect to peer
    pub fn connect(&mut self, peer_contact_info: StaticContactInfo) -> Result<(), Error> {
        let connect_tx = self.connect_tx.clone();
        let event_tx = self.event_tx.clone();

        try!(self.post(move |core, event_loop| {
            // TODO: raise NewPeer(Err, ..) if this fails
            let _ = EstablishConnection::start(core,
                                               event_loop,
                                               peer_contact_info,
                                               connect_tx,
                                               event_tx);
        }));

        Ok(())
    }

    /// Disconnect from the given peer and returns whether there was a connection at all.
    pub fn disconnect(&mut self, peer_id: PeerId) -> bool {
        let handle = match self.connection_map.lock().unwrap().remove(&peer_id) {
            Some(handle) => handle,
            None => return false,
        };

        let _ = self.post(move |mut core, mut event_loop| {
            if let Some(state) = core.get_state(&handle) {
                state.borrow_mut().terminate(&mut core, &mut event_loop);
            }
        });

        true
    }

    /// sending data to a peer(according to it's u64 peer_id)
    pub fn send(&mut self, peer_id: PeerId, data: Vec<u8>) -> Result<(), Error> {
        if data.len() > ::MAX_DATA_LEN as usize {
            return Err(Error::MessageTooLarge);
        }

        // TODO: return Err instead of panicking
        let handle = self.connection_map.lock().unwrap()
                                               .get(&peer_id)
                                               .map(|h| *h)
                                               .expect("Connection not found");

        try!(self.post(move |mut core, mut event_loop| {
            let state = core.get_state(&handle).expect("State not found");
            state.borrow_mut().write(&mut core, &mut event_loop, data);
        }));

        Ok(())
    }

    /// Lookup a mapped udp socket based on result_token
    // TODO: immediate return in case of sender.send() returned with NotificationError
    pub fn prepare_connection_info(&mut self, result_token: u32) {
        // FIXME: If the listeners are directly addressable (direct full cone or upnp mapped etc.
        // then our conact info is our static liseners
        // for udp we can map another socket, but use same local port if accessable/mapped
        // otherwise do following
        let our_static_contact_info = self.static_contact_info.clone();
        let event_tx = self.event_tx.clone();
        let mapping_context = self.mapping_context.clone();
        let our_pub_key = self.our_keys.0.clone();
        if let Err(_) = self.post(move |_, _| {
            let (tcp_socket, (our_priv_tcp_info, our_pub_tcp_info)) =
                match MappedTcpSocket::new(&mapping_context).result_log() {
                    Ok(MappedTcpSocket { socket, endpoints }) => {
                        (Some(socket), gen_rendezvous_info(endpoints))
                    }
                    Err(err) => {
                        let _ =
                            event_tx.send(Event::ConnectionInfoPrepared(ConnectionInfoResult {
                                result_token: result_token,
                                result: Err(From::from(err)),
                            }));
                        return;
                    }
                };

            let event = Event::ConnectionInfoPrepared(ConnectionInfoResult {
                result_token: result_token,
                result: Ok(OurConnectionInfo {
                    id: peer_id::new_id(our_pub_key),
                    tcp_info: our_pub_tcp_info,
                    priv_tcp_info: our_priv_tcp_info,
                    tcp_socket: tcp_socket,
                    static_contact_info: unwrap_result!(our_static_contact_info.lock()).clone(),
                }),
            });
            let _ = event_tx.send(event);
        }) {
            let _ = self.event_tx.send(Event::ConnectionInfoPrepared(ConnectionInfoResult {
                                result_token: result_token,
                                result: Err(io::Error::new(io::ErrorKind::Other,
                                                              format!("Failed to register task \
                                                                       with mio eventloop"))),
                            }));
        }
    }

    fn post<F>(&self, f: F) -> Result<(), NotifyError<CoreMessage>>
        where F: FnOnce(&mut Core, &mut EventLoop<Core>) + Send + 'static
    {
        self.mio_tx.send(CoreMessage::post(f))
    }
}

impl Drop for Service {
    fn drop(&mut self) {
        let _ = self.post(|_, el| el.shutdown());
    }
}

fn start_bootstrap(mio_tx: &mio::Sender<CoreMessage>,
                   config: Config,
                   connection_map: SharedConnectionMap,
                   event_tx: ::CrustEventSender) -> Result<StateHandle, Error> {
    sync(mio_tx, move |mut core, mut event_loop| {
        GetBootstrapContacts::start(core,
                                    event_loop,
                                    &config,
                                    connection_map,
                                    event_tx)
    })
}

fn start_forward_connection_events(mio_tx: &mio::Sender<CoreMessage>,
                                   connection_map: SharedConnectionMap,
                                   event_tx: ::CrustEventSender)
    -> Result<Sender<(StateHandle, Option<PeerId>)>, Error> {
    sync(mio_tx, move |mut core, event_loop| {
        let handle = core.get_new_state_handle();
        let (tx, rx) = channel::new(event_loop, handle);

        try!(ForwardConnectionEvents::start(core,
                                            handle,
                                            connection_map,
                                            rx,
                                            event_tx));
        Ok(tx)
    })
}

// Run the given closure on the event loop thread and wait for its result.
fn sync<F, R>(mio_tx: &mio::Sender<CoreMessage>, f: F) -> Result<R, Error>
    where F: FnOnce(&mut Core, &mut EventLoop<Core>) -> Result<R, Error> + Send + 'static,
          R: Send + 'static
{
    let (tx, rx) = mpsc::channel();

    try!(mio_tx.send(CoreMessage::post(move |mut core, mut event_loop| {
        let _ = tx.send(f(core, event_loop));
    })));

    match rx.recv() {
        Err(err) => Err(From::from(err)),
        Ok(ok) => ok,
    }
}
